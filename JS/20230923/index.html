<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>

<body>
    <script>
        /*
        *  왜 객체지향 프로그래밍을 해야 할까?
        *  1. 깔끔하고 이해하기 쉬운 코드를 짤 수 있다.
        *  2. 확장하기 쉬운 코드를 짤 수 있다.
        *  3. 유지보수 하기 쉬운 코드를 짤 수 있다. 
        *  4. 메모리를 절약하는 코드를 짤 수 있다.
        */


        // 절차지향적 프로그래밍 
        let name = '재현',
            weapon = '검'

        function attack() {
            return `${name}이 ${weapon}으로 공격합니다.`
        }

        function changeWeapon() {
            weapon = '창'
            return `무기가 ${weapon}으로 교체되었습니다.`
        }

        // 객체지향 프로그래밍 
        // encapsulation(캡슐화 한다.) : 데이터와 데이터를 조작하는 메서드들을 하나의 단위로 묶는 것
        /* 문제점
        * 객체를 필요할 때마다 새로 선언해야 한다. 
        * 똑같은 기능을 하는 함수가 반복된다. */
        const knight = {
            name: '재현',
            weapon: '검',
            attack() {
                return `${this.name}이 ${this.weapon}으로 공격합니다.`
                // `${ knight.name }이 ${ knight.weapon }으로 공격합니다.`도 가능하다. 
            },
            changeWeapon(newWeapon) {
                this.weapon = newWeapon;
                return `무기가 ${this.weapon}으로 교체되었습니다.`
            }
        };

        /* 생성자 함수
        *위 문제점을 해결하기 위해 instance를 생성하는 함수로 만들어보자 
        *생성자의 함수는 대문자로 시작 
        *새로운 값을 전달받아서 새로운 객체를 만들 수 있다.  */
        function Knight(name, weapon) {
            this.name = name;
            this.weapon = weapon;
        };

        // 프로토타입
        // 모든 인스턴스가 프로토타입을 관리하기 때문에 함수를 계속 선언할 필요가 없어진다. -> 메모리 공간을 절약할 수 있다. 
        // 그러나 하나로 감싸지 못하고 분리되어 있기 때문에 encapsulation이 되지 않는다. 
        Knight.prototype.attack = function () {
            return `${this.name}이 ${this.weapon}으로 공격합니다.`
        }

        Knight.prototype.changeWeapon = function (newWeapon) {
            return `무기가 ${this.weapon = newWeapon}으로 교체되었습니다.`
        }

        // class 문법은 내부적으로 prototype이 적용 
        // class 문법으로 상당히 쉽게 상속을 받을 수 있음 
        class Knight {
            constructor(name, weapon) {
                this.name = name;
                this.weapon = weapon;
            }

            attack() {
                return `${this.name}이 ${this.weapon}으로 공격합니다.`
            }
            changeWeapon() {
                return `무기가 ${this.weapon = newWeapon}으로 교체되었습니다.`
            }
        }

        // const knight = new Knight('재현', '검');

        class Skeleton extends BaseCharactor {
            // constructor(name, weapon, unitType) {
            //     super(name, weapon);
            //     this.unitType = unitType;
            // }
        }

        const skeleton = new Skeleton("재현", "방패", "악마");



    </script>
</body>

</html>